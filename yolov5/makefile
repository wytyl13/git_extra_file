

# 首先来定义头文件和实现文件的变量

include = ./include

# 这个是g++编译时候可以携带的参数，-g应该是编译该文件支持gdb调试
# -Wall应该是显示编译警告提示
myArgs = -Wall -g


# 这个是使用通配符去定义一个文件列表，你可以理解为列表
# 这个变量中包含多个文件,包含所有的src目录下的所有cpp文件
# obj是我们要生成的.o文件。每个cpp文件都要对应生成一个.o文件
src = $(wildcard ./src/*.cpp)

# 你可以理解为这事一个循环，将src列表中的所有%占位符上的内容
# 不变，其余的全部从src目录替换到obj目录，并且更改文件的后缀为.o
# patsubst这个关键词应该是循环更改
obj = $(patsubst ./src/%.cpp,./obj/%.o,$(src))

# 第一组规则，将所有的.o文件编译为可执行文件并且添加编译参数
# $(obj)是依赖文件，就是.o文件，
# $^表示依赖中的所有文件，就是全部的obj
# $@是目标文件，就是生成的可执行文件，这个规则中的目标是上一个规则中的依赖。
# hello是all规则的依赖，$@就是hello，也就是我们需要生成的可执行文件
# 我们让他生成hello.exe把
# 这组依赖是生成可执行文件，我们要的是生成静态库


# 多个规则之间的依赖会使得makefile从底层往上层执行
# 比如makefile会先看到main目标。它的依赖是hello，也就是我们要生成的
# 静态库，而hello的依赖是obj也就是.o文件，而obj的依赖是.cpp文件。
# makefile找到最后一个依赖发现这个依赖不存在任何依赖，然后它会往上一个个执行
# 对应的规则，和运行栈很像。执行某个函数会看到它依赖某一个函数，然后一直
# 往下走直到没有依赖为止。然后输出。
# 应该是这块生成库文件的时候不能加入参数
main:staticLibHello.a

# ar rcs staticLibName.a *.o
# 应该这样来，我们试试，
staticLibHello.a:$(obj)
	ar rcs $@ $^

# 这组规则的目标是生成obj文件，所以它再冒号前
# 这组的依赖是每个.c文件
# ./obj/%.o:./src/%.c 为什么要这么写，我们的依赖是所有的.cpp文件
# 可能他是要做一个循环，因为我们需要逐个对.cpp文件生成对应的.o文件
# 所以./obj/%.o:./src/%.cpp是做循环
# $<代表的是规则中的第一个依赖，依赖第一个依赖也就是第一个.cpp文件
# 去生成对应的.o文件，然后循环。
# OK我们测试下

$(obj):./obj/%.o:./src/%.cpp
	gcc -c $< -o $@ -I $(include) $(myArgs)



# ar rcs hello src/hello.cpp -Wall -g
# 直接运行的是这个命令,可以发现.o文件并没有被生成
# 看来是下一个规则错误
# $(obj)这个变量没有定义好。

# mingw32-make: Nothing to be done for 'main'.
# 这个是因为已经生成了，而且对应的文件没有做过改变
# 所以编译不执行。这也就是为什么使用makefile可以
# 提升我们的编译效率，但是好像有问题，我们这个
# 生成的是hello，和静态库的样子不像。我们调整下
# OK,调用下试试
# OK， makefile的简单使用就到这里了。








