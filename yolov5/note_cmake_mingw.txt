OK
今天我们来开始libtorch实现yolov5，也就是在c++下实现yolov5

D:\libtorch_yolo_tools
所有的工具和代码文件全部放在这个目录下

libtorch是pytorch对c++开放的接口
直接可以从pytorch官方下载

c++嘛，我们需要一点前馈知识
我们先不急着搞torch那么高级的工具，我们先来了解下c++是如何处理源代码的

c++使用的编译器是g++
这个可以在windows下的mingw实现，我们先来试用下mingw

然后我们一步步把libtorch-yolov5构建起来

首先下载mingw32

不用考虑版本，直接下载
点击页面会自动下载文件
这个得下载好一会。我直接把我刚才下载好的移动过来吧
我刚才试着下载了一下
进去了选择g++即可，g++是编译c++的，gcc是编译c语言的
g++可以兼容gcc，和msvc下载的时候差不多，我直接移动刚才下载的过来吧


所有的可执行文件都在这个bin目录下
我们常用的就是g++
mingw32-make.exe这个是用来执行makefile文件，后续我们再说

我们先从g++开始


因为这个目录下面很多可执行文件，我们可以把它先加入到环境变量中
这样我们可以在终端的任何目录下调用可执行文件了
我不知道mingw是否需要添加环境变量，我们先加上
加上环境变量不知道要不要重启，其实我感觉如果软件自己内部没有调用
这个可执行文件的情况下我们是不需要添加为环境变量的。除非我们自己
在代码中调用了某一个函数，比如opencv中的imshow函数。这个函数它会
调用opencv以外的工具，比如ffmpeg.exe的可执行文件，这样如果我们没有
把这个可执行文件添加到环境变量中，代码在编译的时候会报错
环境变量就是可执行文件所在的目录，将该目录添加到windows系统中
我们可以在任何windows目录下找到该目录，就是这样。我们后续再看
有问题在搞。

我们首先使用g++来测试一个c++文件


    这是我们项目的根目录D:\libtorch_yolo_tools\program
    现在我们在这个项目下构建几个微服务
    首先我们先来构建第一个微服务
    这是我们的头文件
    好吧，这是c++的一个标准的头文件形式


    ifndef和endif是为了防止头文件重复包含的
    include是引入头文件，一般使用<>引入官方头文件
    比如iostream是标准头文件，输入输出流用的
    如果是自己的头文件，使用双引号来
    这个是有一个先后的区别

    在头文件中定义一个函数，一个简单的函数，输出一段话
    为了细致讲解下c++项目架构，其实我们这块使用的还是c的内容
    我们就麻烦点，分别定义头文件和实现文件吧


    现在我们定义该头文件的实现文件
    OK实现文件定义完毕，其实效果就是将头文件include到这个实现文件中
    注意这个就是物理意义上的拼接，但是头文件的作用还有很多，比如
    头文件可以让函数在实现文件中的定义部分先后顺序，这个就是最好的
    可以在我们使用第三方库文件的时候可以找到函数的名称，指导我们需要去
    调用哪一个函数。这两个意义就很大。

    注意这两个文件都没有入口函数，如果想要编译生成执行文件，只能对有
    入口函数的文件进行编译生成。而且一个可执行文件对应一个入口函数。也就是一个
    编译命令对应的源代码文件中只能有一个入口函数，因为一个编译命令只能生成一个
    可执行文件。下面我们来定义入口函数

    这是一个简单的入口函数，return0是入口函数的一个返回值，这个返回值可以判断
    程序是正常返回还是中断返回，0以外的编号都是异常返回，这个编号我们可以在
    任何函数中返回。倒数第二行是一个程序执行完成后不退出中断，提示操作任何按键后
    退出。

    我们在改文件中定义了一个入口函数，同时引入了刚才定义的头文件，并且在入口函数中
    调用了该头文件中的一个函数。我们试着编译一下。

    我们在项目的一级目录下编译，注意只需要把文件的路径找对就行

    g++ <all cpp files> 
        如果没有头文件，这就是一个简单的编译代码
    g++ <all cpp files> -I includePath
        这个是包含头文件的编译指令
    加入-o参数可以指定输出可执行文件的名称
    OK，我们已经编译好了可执行文件

下面我们来定义第二个微服务，我们希望在第二个微服务中调用这个微服务中
的函数。这个怎么实现？
    我们使用vscode打开吧
    这个我们其实也可以像刚才一样去调用刚才那个头文件
    这个报错不用管，我们后续处理，这个是vscode编辑器的代码错误识别
    和编译没有关系，是一个代码错误提示。不影响编译，我们只需要
    确定路径正确即可。

    我们直接在这个cpp文件中定义入口函数吧
    好了我们现在编译第二个微服务,注意我们现在遇到了一个问题
    undefined reference to `general
    这个错误在c中很常见，那就是我们使用了头文件，但是编译器没有找到
    对应的实现文件或者没有指定对应的库文件
    那么很简单就是我们编译的时候把他的实现文件也带上
    OK，现在大家对编译有了解了吗？我们继续深入


    我们在定义第二个服务中发现了一个问题，就是我们虽然可以在编译的时候调用
    第一个微服务中的头文件和实现文件，但是操作起来很麻烦，特别是当实现文件和头文件
    有很多的情况下，这时，我们可以将第一个微服务编译为库文件，然后再
    第二个微服务中直接调用第一个微服务生成的库文件即可。因为库文件可以只调用一个
    而实现文件却有很多

    我们现在来将第一个服务编译为库文件。注意含有主函数的文件一般不能编译为
    库文件。因为主函数是用来调用的。所以我们在编译库文件的时候不要带上主函数文件
    我们可以将第一个微服务中的所有cpp文件编译为库文件，这块之前是理解错误，其实带不带都可以，是不是可以这样理解

    下来我们操作一下
        库文件是基于.o也就是object文件进行编译的，object是程序代码像机器代码转换
        过程中一个很重要的步骤，其实主要还是预处理阶段的多一点，即是将头文件物理
        添加到实现文件中。我看下之前的资料，顺便了解下机器代码是怎么实现的。


        预处理->编译->汇编->链接
        预处理：处理头文件和宏定义
        编译：生成.s文件	-S   也就是汇编代码，为下一步的汇编做准备。我们研究汇编也就是研究这个文件
        汇编：生成.o文件   -c
        链接：静态、动态链接库， 找到使用的那些库。
        
        对汇编阶段会生成.o文件，对应的编译参数是-c
        注意每一个cpp文件都会生成一个对应的.o文件
        大家可以了解下这个机器代码生成的过程
        gcc -c *.cpp
        就是这么简单，但是应该需要指定头文件目录
        我们将生成的.o文件放在obj目录下，竟然不需要指定头文件路径。。。
        这是我没有想到的。但是也是，这个实现文件中已经指明了头文件的地址了
        这个main.cpp是主函数，不需要生成.o文件，但是应该也需要，我想想

        这个还是需要生成.o文件的，因为生成objec文件是编译的必经步骤，所以主函数文件也要生成
        所以我们直接对这两个函数都生成object文件吧
        然后基于这两个object文件去生成库文件，库文件包含静态库和动态库
        顾名思义，静态库就是静态添加到可执行文件中的，也就是可执行文件中已经
        包含了静态库的函数信息和地址信息，所在在链接阶段，静态库其实做的工作很多、
        而动态库是在程序执行的过程中，也就是我们在执行可执行文件的过程中采取寻址操作的
        所以可执行文件中不包含动态库的一些地址信息。所以，静态库编译阶段时间较长，但是
        执行阶段快，而动态库刚好相反，编译快，执行慢。这个其实大家以后再使用一些第三方
        库的时候就深有体会，比如我之前使用的dlib库，它就是一个静态库，编译的时候老慢了

        静态库生成指令，忘记了我查下
            ar rcs staticLibName.a *.o//生成库文件
            注意在windows中staticLib是静态库的前缀，.a是后缀，中间是库名
            我们在生成的时候按照这种格式定义名称
        下来我们在第二个微服务中直接调用第一个微服务生成的静态库
            g++ .\src\*.cpp 静态库即可
            OK我们已经调用了对应的静态库，是不是很简单

    好吧，现在又出现了一个问题，就是编译静态库的时候我们需要的依赖文件是object文件
    在现实项目中如果存在多个实现文件，我们是否都需要一个个命令去生成对应的object文件？
    这样显得很麻烦，此时，cmake来了。cmake可以管理编译命令，让我们的编译更加方便
    cmake对编译命令的转换最直接的时makefile文件，我们可以先从makefile文件入手

    makefile
        makefile的简单格式是这样的
        比如第二个微服务。main是一个键值，我们使用makefile的命令执行main
        就会执行对应main下的内容，你也可以理解其为一个规则。main规则
        规则下面可以使用命令，试着使用makefile执行下刚才的命令
        注意makefile是cmake管理工具的文件，是直接可以和命令行交互的文件
        mingw中开放了对makefile文件的一个执行命令，即可以使用mingw中的
        命令直接执行makefile文件。这个是mingw专属。msvc中是不存在的。所以
        cmake结合msvc是不会生成makefile文件的
        执行makefile文件的命令就是刚才提到的mingw32-make.exe
        就是这个文件下D:\libtorch_yolo_tools\mingw32_\bin
        如果你已经把这个bin目录添加到系统环境变量中，那么你可以在终端的任何
        目录下调用该可执行文件，如果没有，那么你就使用绝对路径
        我找下，好像我这个里面没有，没有的话那就应该是下载的时候没有选择
        却是没有，那就是刚才下载的时候选择的版本没有带这个。
        刚才选择的版本是最小的只适合于c++编译的
        是不是应该选择mingw32-base这个。大家可以试一下。我就不下载了
        我直接使用我之前的吧。
        后续可以再看看这个版本
        我先给大家看下我之前安装的mingw，看，如果你将bin目录添加到环境
        变量中，那么你可以在任何目录下访问到该bin目录下的所有可执行文件
        比如我这个mingw32-make.exe是在这个目录下
        D:\mingw64-posix\bin\mingw32-make.exe

        好吧我直接使用这个去执行makefile文件
            我把makefile文件移动到第二个微服务的根目录下
            直接执行该命令即可，它会直接找到当前执行目录下的makefile文件
            它可能不认识*通配符，我们更换下
            OK我们看到它其实是执行了一模一样的命令在终端
        那么如果他只有这个功能，我们是不足以有理由在很多大项目中用到它的
        

        我们试着在第一个微服务中使用makefile来管理下编译
            # 我们可以定义一些规则，注意多个规则之间的执行顺序
            # makefile会从向上往下读取每一个规则，什么是规则？这就是一个规则，在命令行执行jdoejoefjo
            # 那么什么是多个规则呢？这里注意一些名词，main是第一个规则，我好像忘记了，我参考下之前了解的内容，好久没看了
            # 还有一个名词是目标，不对
            # 冒号前面的时目标，冒号后面的是依赖，也即生成该目标需要的依赖文件。比如
            # 生成可执行文件需要依赖.o文件，那么前者就是目标，后者是依赖，那么某一个依赖可能是另一个规则中的目标
            # 比如下面的obj文件的依赖文件就是.c文件，gcc -c *.cpp
            # 我想应该讲清楚了，为什么一定要这样呢？
            # 直接gcc *.c -o -I include就可以不是吗，简单的很、
            # 注意两点，第一，这个命令不会生成.o文件，有时候我们需要，比如生成库文件的时候。第二点最重要，我们不需要重复编译。
            # 也就是对已经编译过的项目，如果对应的文件没有做更改，我们就不需要重新编译它。这个可以加快项目的编译速度。
            # 比如我打开一个项目大家看看
            # 这个项目里面每一个文件夹对应都是一个微服务。如果编译一次需要花费很长时间
            # 那么如果我只对后续新进的文件做更改，那么之前编译过的文件就不需要再进行编译
            # 这样时间很快，我可以演示一下。大家看这个速度其实很慢。这是因为我可能把之前
            # 编译时候缓存的文件删除了。我们等他编译完再看吧，不对好像这个是编译过的
            # 你看是不是这次速度很快。这个很重要，就是因为我们有了这个过程.
            # 我们继续,稍等下待会继续.

            # 好了我们继续
            # 上次我们讲到了如何使用mingw编译自己的c++项目
            # 还包括一些管理编译命令的工具,比如cmake的makefile文件
            # 我们可以使用mingw32-make.exe命令去执行当前目录下的makefile文件
            # 最后我们了解了一下makefile的规则，比如下面的这两个规则，我们可以依赖规则之间的
            # 依赖去生成多个命令，并去命令行执行。好吧我们直接使用makefile的规则去
            # 编译生成第一个服务的静态库把。
            # 上个视频中下载的mingw没有mingw32-make这个可执行文件。我现在重新选择一个版本
            # 试下。让他去下载我们开始下面的内容。


            # 我们看下mingw下载的怎么样了,刚才选择的这个base版本可以.
                直接将其D:\libtorch_yolo_tools\mingw\bin添加到系统环境变量中就可以使用了
                或者直接将其添加到终端上.我使用的是powershell终端.可以将这个命令更改个别名
                比如:这样保存下就可以在powershell中打开了.
                $profile直接就可以定位到该文件Microsoft.PowerShell_profile.ps1是这个文件
                每次打开一个powershell终端都会执行改文件,所以改文件的更新只需要重启一下终端就行.不需要重启电脑
                如果有的命令在终端不能执行,都可以这样操作,这个操作只适用于powershell

        好了我们已经简单了解了下makefile,我们继续下一个话题
        那么makefile这样方便,足够我们的使用了吗?像刚才我打开的那个微服务项目,如果一个项目下面有很多个服务.而这些服务之间又都存在
        互相调用的情况,那么对每个服务都自己去编写makefile是非常大的工作量.像刚才我们只是编写了一个微服务对应的makefile
        已经写了很久了.那么cmake提供了一个脚本文件,我们可以按照规则去自动生成项目对应的makefile文件,下面我们来试用下
        就是CMakeLists.txt文件，我们可以按照这个文件的编写规则来自动生成makefile文件。而且这些文件之间可以互相管理
            比如我可以在项目的根目录下定义一个cmakelists文件来专门做管理
            然后再每个微服务项目下定义自己的cmakelist文件去生成makefile
            注意项目的cmakelists只是管理微服务下的cmakelist，微服务下的cmakelist真正的用来生成makefile
            这有点像多线程。其中有一个是管理线程。其余的线程是工作线程

            我们先把makefile文件删除了
            我们把这个makefile文件移动到上级目录，这里面还有很多内容
            首先我们来定义管理cmakelist文件

            我们定义了一个管理文件，下面我们先试着运行一下。注意这个时候才是用到了
            cmake的工具，因为我们要使用cmake工具来执行cmakelist中的规则
            让其生成对应的makefile文件。那么这和直接编写makefile有什么区别呢？编写makefile一定比编写cmakeliests文件复杂吗？
            当然，cmakelists的规则编写比makefile简单多了。
            我们可以使用ctrl+shift+p -> cmake调用cmake命令
            但是我们需要先下载cmake
                注意这个是源码安装，当然可以下载他，不过我想的是我们使用源码安装不是要使用
                到cmake去将官方在源码中定义的cmakelists文件编译为makefile文件，然后使用mingw
                的mingw32-make.exe去编译源码项目，然后安装吗？那么我们怎么去使用cmake去编译
                安装cmake呢？哈哈。前提是你的电脑上要有一个cmake。所以我们这里直接下载压缩包
                解压一下就ok，直接就是二进制的安装包。好像很慢，我之前下载了一份，咱么直接解压
                注意cmake在源码安装中经常被使用。后续的yolov5 c++部署需要安装好几个第三方库
                比如opencv、libtorch等等。如果不会使用cmake安装会相当吃力，这也是为什么花这么久
                从基础的mingw到cmake的讲解。到这cmake其实已经可以编译安装所有的三方库了。
                我们其实已经学会了怎么去编译安装自己的项目，那么第三方库也是一个道理，都是源码，只不过
                第三方库需要生成的库很多。安装时间久。

                同样的，cmake和mingw一样。我们只需要关注bin目录下的两个命令
                    cmake-gui.exe和cmake.exe
                    前面是可视化cmake，后者是命令行cmake
                    D:\libtorch_yolo_tools\cmake-3.27.3-windows-x86_64\bin
                    同理添加到环境变量或者在$profile文件中起别名
                    这里我已经起号别名了，就是cmake
                下载好cmake以后就可以在vscode中使用了
                    这里要选择一个编译器。选择mingw即可，因为cmake只是编译
                    命令管理工具，他需要搭配编译器一起使用。
                    这步操作的命令行其实是cmake -G "MinGW Makefiles" ./
                    意思是调用cmake命令对当前目录下的cmakelists文件使用mingw
                    进行编译，生成makefile文件在当前目录

                    他回去调用执行对应的项目，这两个项目没有被定义，所以报错了
                我们接下来定义微服务的cmakelist
                    注意cmake命令会自动生成build文件。它会在当前目录下生成
                    对应的makefile文件，所以我们一般是在项目一级目录下创建一个build
                    文件，然后进入到build目录下，然后再该目录下调用上一级目录中的cmakelist文件

                我们已经定义了微服务的cmakelist文件，这里需要强调一点。cmake是配置编译器
                对项目的编译进行管理的，所以这一切都和项目的编译有关系，只要项目能通过编译
                就可以生成可执行文件，运行。这里要把编译和编辑器分开。一般的编辑器都会有代码
                错误提示，而且也会在编辑器这个层面进行错误识别，如果编辑器识别到了调用或者语法错误
                是不会被执行编译的。当然如果你直接在命令行进行编译，编辑器是管不着的。
                编辑器也可以进行项目的编译和运行，比如vscode，这个命令他其实并不智能
                他和我们在命令行先进行编译，然后执行可执行文件是一个道理，他是将我们的这两部操作
                融合到了一个task任务中，然后我们可以使用文件去定义task任务，vscode中使用的是json文件
                    c_cpp_properties.json这个文件就是vscode编辑器对项目管理的一个依据
                    如果你把项目中使用的头文件添加到下面的这个路径中，代码编辑器就能默认通过
                    而且还可以进行函数的追踪和回退。这个是编辑器的一个很好的功能，如果我们使用
                    普通的文本编辑器，比如这个，我们用文本编辑器写代码会很不顺畅，所以这个功能还是必要的。
                    我们先把编译弄通，然后再去考虑文本编辑层面的东西。
                    "includePath": [
                    "${workspaceFolder}/**"

                    task任务是通过json文件实现的。
                    在这个文件中定义task任务，实现编译和运行。但是我们在makefile中也可以
                    实现这个功能。后续在考虑这个。先通过编译




                下面我们来定义第二个微服务的cmakelists
                OKcmakelist文件全部定义完成。
                其实此时我们就可以使用cmake去生成对应的makefile了
                因为我们在第一个微服务中做了相关设置，所以我们可以直接在第二个微服务中调用第一个
                微服务中的头文件，不用加路径、很方便

                因为我们在每一个微服务的cmakelist中都添加了该微服务中的include includePath
                所以我们可以直接添加头文件
                    这里注意如果这样操作整个项目下就不能有重复的头文件，否则
                    会存在二义性。
                

                [cmake] -- Configuring done
                [cmake] -- Generating done
                [cmake] -- Build files have been written to: D:/libtorch_yolo_tools/program/build

                点击一下管理cmakelist文件，可以使用ctrl+s，直接
                会调用cmake -G "MinGW Makefiles" ..
                第一次使用cmake可以使用ctrl+shift+p -> cmake configure
                lib库的头文件报错引起的所有的添加该头文件的文件都报错
                我们需要解决一下。但是这个应该不影响编译。我们试着编译一下
                注意点击了ctrl+s其实已经生成makefile文件，我们直接在build
                目录下使用migw32-make.exe命令即可
                看来是在第二个微服务中直接添加第一个微服务中的头文件报错了
                我们检查下cmakelist文件

                应该是这个错误了。我们查看下文档。没毛病
                OK使我们添加库文件错误了。
                target_link_libraries(${PROJECT_NAME} FIRST)
                注意这个和link_libraries的区别，应该是前者需要写库文件全程
                比如staticLibFIRST.a,但是这个只需要写FIRST即可
                所以添加库失败肯定会导致编译失败

                可以看到build项目下first文件夹下生成了库文件
                而second下生成了可执行文件

                如果项目要在这个基础上添加，只需要每添加一个微服务，根据微服务的定位
                添加对应的cmakelist文件即可。注意最后还需要再管理cmakelist文件
                中add_subdirectory(SECOND),这里注意编译顺序，先编译的在前，后编译的在后。

        OK到这如何使用cmake + mingw去构建自己的c/c++项目已经清除了
        我相信大家也都会了，如果有疑问的欢迎在评论区交流讨论

        我在视频中也有很多未知的东西需要向大家请教

        下来我们就是使用cmake+mingw/MSVC去源码安装libtorch-yolo的一些
        依赖库，并且使用cmake+MSVC去编译我们自己的libtorch-yolo项目

        MSVC是微软的编译器，其实主要还是编译c++的，它的编译原理和mingw一样
        会mingw，也会MSVC。为什么要使用MSVC呢？因为libtorch在windows上只能
        使用MSVC去编译，在linux上可以使用g++去编译libtorch

        好了感谢大家。
        未完待续。。。。。































            












































































        




































































































































































































